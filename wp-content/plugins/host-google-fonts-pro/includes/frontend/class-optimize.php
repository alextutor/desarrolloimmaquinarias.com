<?php
defined('ABSPATH') || exit;

/**
 * @package   OMGF Pro
 * @author    Daan van den Bergh
 *            https://ffw.press
 *            https://daan.dev
 * @copyright Â© 2021 Daan van den Bergh
 * @license   BY-NC-ND-4.0
 *            http://creativecommons.org/licenses/by-nc-nd/4.0/
 */
class OmgfPro_Frontend_Optimize extends OmgfPro_HtmlParser
{
    const OMGF_OPTION_FONT_PROCESSING = 'omgf_font_processing';
    const OMGF_PRO_MERGED_HANDLE      = 'pro-merged';

    /**
     * Hooks and filters.
     */
    public function __construct()
    {
        /**
         * Is used by OMGF to properly load preloads.
         */
        add_filter('omgf_pro_merged_handle', [$this, 'fetch_stylesheet_handle'], 10, 2);

        /**
         * If Advanced Processing is 'off', the stylesheet is enqueued and processed by OMGF, 
         * instead of being inserted by OMGF Pro's HTML parser.
         */
        add_action('wp_enqueue_scripts', [$this, 'maybe_register_stylesheet']);
        add_filter('omgf_replace_detected_stylesheets', [$this, 'insert_merged_stylesheet']);

        /**
         * If Advanced Processing is 'off', we want to avoid using the HTML Parser. That's why
         * we only scan through enqueued stylesheets to insert fallbacks.
         */
        add_action('wp_enqueue_scripts', [$this, 'insert_fallback_font_stacks'], 10000);

        if (class_exists('WpFastestCache')) {
            // WP Fastest Cache runs at runtime, but doesn't work with wp_loaded. template_redirect runs later.
            add_action('template_redirect', function () {
                ob_start([$this, 'init']);
            }, 1);
        }

        if (class_exists('Nextend\WordPress\OutputBuffer')) {
            // Smart Slider 3 has its own filter to hook into. So there's no need to start our own output buffer.
            add_filter('wordpress_prepare_output', function ($buffer) {
                $buffer = $this->init($buffer);
                return $buffer;
            });
        }

        /**
         * - Autoptimize runs at template_redirect, priority 2. wp_loaded runs beforehand.
         * - LiteSpeed Cache runs at runtime. Tested on local LiteSpeed docker image and couldn't find issues. 
         *   Stylesheet generated by OMGF Pro is aggregated properly.
         * - WP CloudFlare Super Page Cache runs at 'shutdown'. Not tested, but shouldn't cause issues.
         * - WP Optimize (minification and Google Fonts optimizations) runs at 'wp'. wp_loaded runs beforehand.
         * - WP Rocket runs at template_redirect, priority 2. wp_loaded runs beforehand.
         * - WP Super Cache runs at init (late load) or runtime. works.
         * 
         * TODO: Slider Plugins
         * - Revolution Slider
         */
        add_action('wp_loaded', function () {
            ob_start([$this, 'init']);
        }, 1);
    }

    /**
     * @since v2.5.2 Added (back) 2nd $dummy param. To prevent fatal errors after updating.
     * @see OMGF_Frontend_Functions::add_preloads()
     * 
     * @param mixed $handle 
     * @param mixed $dummy 
     * @return string|false 
     */
    public function fetch_stylesheet_handle($handle = '', $dummy = '')
    {
        if (!$handle) {
            $handle = $this->get_cache_handle();
        }

        if (strpos($handle, 'mod') !== false) {
            preg_match('/.+?(?=-mod)/', $this->get_cache_handle(), $handle);

            return $handle[0] ?? false;
        }

        return $handle;
    }

    /**
     * If Advanced Processing is 'off', OMGF Pro only takes care of the backend tasks, i.e.
     * generating the stylesheet. OMGF takes care of adding it in the frontend thru regular
     * enqueueing.
     * 
     * If Advanced Processing is 'off' and Optimization Mode is set to 'Automatic', OMGF Pro still
     * only takes care of the backend tasks, but it also makes sure the proper stylesheet handle 
     * is stored in the post/page/taxonomy's meta table, e.g. postmeta or termmeta and it's passed
     * to OMGF's frontend processing logic (OMGF_Frontend_Functions()).
     * 
     * We enqueue the stylesheet handle, with source set to 'dummy'. insert_merged_stylesheet()
     * will set the source properly.
     * 
     * @see OMGF_Optimize()
     * 
     * @since v2.6.0
     */
    public function maybe_register_stylesheet()
    {
        if (OMGF_PRO_ADVANCED_PROCESSING == 'on') {
            return;
        }

        if (OMGF_PRO_OPTIMIZATION_MODE == 'auto') {
            $handle = $this->get_cache_handle();

            /**
             * If no handle is present, assume that Automatic's cron hasn't reached this page/post yet.
             */
            if (!$handle) {
                return;
            }

            wp_enqueue_style($handle, 'dummy');

            return;
        }

        wp_enqueue_style(self::OMGF_PRO_MERGED_HANDLE, 'dummy');
    }

    /**
     * Generate a merged API URL from the page's source and insert it into the array
     * registered stylesheets.
     * 
     * @param array of WP_Dependency()
     * 
     * @see WP_Styles()
     * 
     * @since v2.6.0
     */
    public function insert_merged_stylesheet($stylesheets)
    {
        if (OMGF_PRO_ADVANCED_PROCESSING == 'on') {
            return $stylesheets;
        }

        global $wp_styles;

        /**
         * With great power comes great responsibility...
         * 
         * Fix: make sure we don't enqueue WP Admin fonts
         */
        unset($stylesheets['wp-editor-font']);
        unset($stylesheets['open-sans']);

        /** @var WP_Dependency $stylesheet */
        foreach ($stylesheets as $stylesheet) {
            $src[] = $stylesheet->src;
        }

        $merged_url        = $this->merge($src);
        $registered_handle = OMGF_PRO_OPTIMIZATION_MODE == 'auto' ? $this->get_cache_handle() : 'pro-merged';

        /**
         * If no registered handle is present, let's assume the cron hasn't reached this page yet.
         */
        if (!$registered_handle) {
            return $stylesheets;
        }

        $wp_styles->registered[$registered_handle]->src = $merged_url;

        foreach ($stylesheets as $handle => &$stylesheet) {
            $wp_styles->registered[$handle]->src = '';
        }

        $stylesheets[$registered_handle] = $wp_styles->registered[$registered_handle];

        return $stylesheets;
    }

    /**
     * Initialize hooks and filters.
     * 
     * wp_ob_end_flush_all() takes care of flushing the buffer.
     */
    private function init($html)
    {
        if (!$html) {
            return $html;
        }

        $this->get_document($html);

        if (!$this->document) {
            return $html;
        }

        $this->capture_all();
        $this->optimize();

        return $this->html;
    }

    /**
     * Run optimization.
     */
    public function optimize()
    {
        if (OMGF_FONT_PROCESSING == 'replace') {
            $this->html = $this->init_auto_replace();
        }

        /**
         * If cache handle is set, we can assume that the corresponding file exists.
         * 
         * @since v3.0.2 Fix: only remove Google Fonts if handle is generated.
         */
        if ($this->get_cache_handle()) {
            $this->html = $this->init_auto_remove();
        }

        $this->html = $this->insert_fallback_font_stacks_advanced();
    }

    /**
     * 
     * @return void 
     */
    public function insert_fallback_font_stacks()
    {
        if (OMGF_PRO_ADVANCED_PROCESSING == 'on') {
            return;
        }

        $ffs = new OmgfPro_Frontend_FallbackFontStacks($this);

        return $ffs->insert();
    }

    /**
     * @return string 
     */
    private function insert_fallback_font_stacks_advanced()
    {
        $ffs = new OmgfPro_Frontend_FallbackFontStacks($this);

        return $ffs->insert_advanced();
    }

    /**
     * @return string
     */
    public function init_auto_replace()
    {
        $replace = new OmgfPro_Frontend_AutoReplace($this);

        return $replace->init();
    }

    /**
     * @return string
     */
    public function init_auto_remove()
    {
        $remove = new OmgfPro_Frontend_AutoRemove($this);

        return $remove->init();
    }
}
